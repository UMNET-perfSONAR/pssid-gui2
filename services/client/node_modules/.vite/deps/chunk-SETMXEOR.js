// node_modules/mustache/mustache.mjs
var objectToString = Object.prototype.toString;
var isArray = Array.isArray || function isArrayPolyfill(object) {
  return objectToString.call(object) === "[object Array]";
};
function isFunction(object) {
  return typeof object === "function";
}
function typeStr(obj) {
  return isArray(obj) ? "array" : typeof obj;
}
function escapeRegExp(string) {
  return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function hasProperty(obj, propName) {
  return obj != null && typeof obj === "object" && propName in obj;
}
function primitiveHasOwnProperty(primitive, propName) {
  return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
}
var regExpTest = RegExp.prototype.test;
function testRegExp(re2, string) {
  return regExpTest.call(re2, string);
}
var nonSpaceRe = /\S/;
function isWhitespace(string) {
  return !testRegExp(nonSpaceRe, string);
}
var entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(string) {
  return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
    return entityMap[s];
  });
}
var whiteRe = /\s*/;
var spaceRe = /\s+/;
var equalsRe = /\s*=/;
var curlyRe = /\s*\}/;
var tagRe = /#|\^|\/|>|\{|&|=|!/;
function parseTemplate(template, tags) {
  if (!template)
    return [];
  var lineHasNonSpace = false;
  var sections = [];
  var tokens = [];
  var spaces = [];
  var hasTag = false;
  var nonSpace = false;
  var indentation = "";
  var tagIndex = 0;
  function stripSpace() {
    if (hasTag && !nonSpace) {
      while (spaces.length)
        delete tokens[spaces.pop()];
    } else {
      spaces = [];
    }
    hasTag = false;
    nonSpace = false;
  }
  var openingTagRe, closingTagRe, closingCurlyRe;
  function compileTags(tagsToCompile) {
    if (typeof tagsToCompile === "string")
      tagsToCompile = tagsToCompile.split(spaceRe, 2);
    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
      throw new Error("Invalid tags: " + tagsToCompile);
    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
    closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
    closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
  }
  compileTags(tags || mustache.tags);
  var scanner = new Scanner(template);
  var start, type, value2, chr, token, openSection;
  while (!scanner.eos()) {
    start = scanner.pos;
    value2 = scanner.scanUntil(openingTagRe);
    if (value2) {
      for (var i = 0, valueLength = value2.length; i < valueLength; ++i) {
        chr = value2.charAt(i);
        if (isWhitespace(chr)) {
          spaces.push(tokens.length);
          indentation += chr;
        } else {
          nonSpace = true;
          lineHasNonSpace = true;
          indentation += " ";
        }
        tokens.push(["text", chr, start, start + 1]);
        start += 1;
        if (chr === "\n") {
          stripSpace();
          indentation = "";
          tagIndex = 0;
          lineHasNonSpace = false;
        }
      }
    }
    if (!scanner.scan(openingTagRe))
      break;
    hasTag = true;
    type = scanner.scan(tagRe) || "name";
    scanner.scan(whiteRe);
    if (type === "=") {
      value2 = scanner.scanUntil(equalsRe);
      scanner.scan(equalsRe);
      scanner.scanUntil(closingTagRe);
    } else if (type === "{") {
      value2 = scanner.scanUntil(closingCurlyRe);
      scanner.scan(curlyRe);
      scanner.scanUntil(closingTagRe);
      type = "&";
    } else {
      value2 = scanner.scanUntil(closingTagRe);
    }
    if (!scanner.scan(closingTagRe))
      throw new Error("Unclosed tag at " + scanner.pos);
    if (type == ">") {
      token = [type, value2, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
    } else {
      token = [type, value2, start, scanner.pos];
    }
    tagIndex++;
    tokens.push(token);
    if (type === "#" || type === "^") {
      sections.push(token);
    } else if (type === "/") {
      openSection = sections.pop();
      if (!openSection)
        throw new Error('Unopened section "' + value2 + '" at ' + start);
      if (openSection[1] !== value2)
        throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
    } else if (type === "name" || type === "{" || type === "&") {
      nonSpace = true;
    } else if (type === "=") {
      compileTags(value2);
    }
  }
  stripSpace();
  openSection = sections.pop();
  if (openSection)
    throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
  return nestTokens(squashTokens(tokens));
}
function squashTokens(tokens) {
  var squashedTokens = [];
  var token, lastToken;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    if (token) {
      if (token[0] === "text" && lastToken && lastToken[0] === "text") {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        squashedTokens.push(token);
        lastToken = token;
      }
    }
  }
  return squashedTokens;
}
function nestTokens(tokens) {
  var nestedTokens = [];
  var collector = nestedTokens;
  var sections = [];
  var token, section;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    token = tokens[i];
    switch (token[0]) {
      case "#":
      case "^":
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case "/":
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
    }
  }
  return nestedTokens;
}
function Scanner(string) {
  this.string = string;
  this.tail = string;
  this.pos = 0;
}
Scanner.prototype.eos = function eos() {
  return this.tail === "";
};
Scanner.prototype.scan = function scan(re2) {
  var match = this.tail.match(re2);
  if (!match || match.index !== 0)
    return "";
  var string = match[0];
  this.tail = this.tail.substring(string.length);
  this.pos += string.length;
  return string;
};
Scanner.prototype.scanUntil = function scanUntil(re2) {
  var index = this.tail.search(re2), match;
  switch (index) {
    case -1:
      match = this.tail;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
  }
  this.pos += match.length;
  return match;
};
function Context(view, parentContext) {
  this.view = view;
  this.cache = { ".": this.view };
  this.parent = parentContext;
}
Context.prototype.push = function push(view) {
  return new Context(view, this);
};
Context.prototype.lookup = function lookup(name) {
  var cache = this.cache;
  var value2;
  if (cache.hasOwnProperty(name)) {
    value2 = cache[name];
  } else {
    var context = this, intermediateValue, names, index, lookupHit = false;
    while (context) {
      if (name.indexOf(".") > 0) {
        intermediateValue = context.view;
        names = name.split(".");
        index = 0;
        while (intermediateValue != null && index < names.length) {
          if (index === names.length - 1)
            lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
          intermediateValue = intermediateValue[names[index++]];
        }
      } else {
        intermediateValue = context.view[name];
        lookupHit = hasProperty(context.view, name);
      }
      if (lookupHit) {
        value2 = intermediateValue;
        break;
      }
      context = context.parent;
    }
    cache[name] = value2;
  }
  if (isFunction(value2))
    value2 = value2.call(this.view);
  return value2;
};
function Writer() {
  this.templateCache = {
    _cache: {},
    set: function set(key, value2) {
      this._cache[key] = value2;
    },
    get: function get(key) {
      return this._cache[key];
    },
    clear: function clear() {
      this._cache = {};
    }
  };
}
Writer.prototype.clearCache = function clearCache() {
  if (typeof this.templateCache !== "undefined") {
    this.templateCache.clear();
  }
};
Writer.prototype.parse = function parse(template, tags) {
  var cache = this.templateCache;
  var cacheKey = template + ":" + (tags || mustache.tags).join(":");
  var isCacheEnabled = typeof cache !== "undefined";
  var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
  if (tokens == void 0) {
    tokens = parseTemplate(template, tags);
    isCacheEnabled && cache.set(cacheKey, tokens);
  }
  return tokens;
};
Writer.prototype.render = function render(template, view, partials, config) {
  var tags = this.getConfigTags(config);
  var tokens = this.parse(template, tags);
  var context = view instanceof Context ? view : new Context(view, void 0);
  return this.renderTokens(tokens, context, partials, template, config);
};
Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
  var buffer = "";
  var token, symbol, value2;
  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
    value2 = void 0;
    token = tokens[i];
    symbol = token[0];
    if (symbol === "#")
      value2 = this.renderSection(token, context, partials, originalTemplate, config);
    else if (symbol === "^")
      value2 = this.renderInverted(token, context, partials, originalTemplate, config);
    else if (symbol === ">")
      value2 = this.renderPartial(token, context, partials, config);
    else if (symbol === "&")
      value2 = this.unescapedValue(token, context);
    else if (symbol === "name")
      value2 = this.escapedValue(token, context, config);
    else if (symbol === "text")
      value2 = this.rawValue(token);
    if (value2 !== void 0)
      buffer += value2;
  }
  return buffer;
};
Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
  var self = this;
  var buffer = "";
  var value2 = context.lookup(token[1]);
  function subRender(template) {
    return self.render(template, context, partials, config);
  }
  if (!value2)
    return;
  if (isArray(value2)) {
    for (var j = 0, valueLength = value2.length; j < valueLength; ++j) {
      buffer += this.renderTokens(token[4], context.push(value2[j]), partials, originalTemplate, config);
    }
  } else if (typeof value2 === "object" || typeof value2 === "string" || typeof value2 === "number") {
    buffer += this.renderTokens(token[4], context.push(value2), partials, originalTemplate, config);
  } else if (isFunction(value2)) {
    if (typeof originalTemplate !== "string")
      throw new Error("Cannot use higher-order sections without the original template");
    value2 = value2.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
    if (value2 != null)
      buffer += value2;
  } else {
    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
  }
  return buffer;
};
Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
  var value2 = context.lookup(token[1]);
  if (!value2 || isArray(value2) && value2.length === 0)
    return this.renderTokens(token[4], context, partials, originalTemplate, config);
};
Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
  var filteredIndentation = indentation.replace(/[^ \t]/g, "");
  var partialByNl = partial.split("\n");
  for (var i = 0; i < partialByNl.length; i++) {
    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
      partialByNl[i] = filteredIndentation + partialByNl[i];
    }
  }
  return partialByNl.join("\n");
};
Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
  if (!partials)
    return;
  var tags = this.getConfigTags(config);
  var value2 = isFunction(partials) ? partials(token[1]) : partials[token[1]];
  if (value2 != null) {
    var lineHasNonSpace = token[6];
    var tagIndex = token[5];
    var indentation = token[4];
    var indentedValue = value2;
    if (tagIndex == 0 && indentation) {
      indentedValue = this.indentPartial(value2, indentation, lineHasNonSpace);
    }
    var tokens = this.parse(indentedValue, tags);
    return this.renderTokens(tokens, context, partials, indentedValue, config);
  }
};
Writer.prototype.unescapedValue = function unescapedValue(token, context) {
  var value2 = context.lookup(token[1]);
  if (value2 != null)
    return value2;
};
Writer.prototype.escapedValue = function escapedValue(token, context, config) {
  var escape = this.getConfigEscape(config) || mustache.escape;
  var value2 = context.lookup(token[1]);
  if (value2 != null)
    return typeof value2 === "number" && escape === mustache.escape ? String(value2) : escape(value2);
};
Writer.prototype.rawValue = function rawValue(token) {
  return token[1];
};
Writer.prototype.getConfigTags = function getConfigTags(config) {
  if (isArray(config)) {
    return config;
  } else if (config && typeof config === "object") {
    return config.tags;
  } else {
    return void 0;
  }
};
Writer.prototype.getConfigEscape = function getConfigEscape(config) {
  if (config && typeof config === "object" && !isArray(config)) {
    return config.escape;
  } else {
    return void 0;
  }
};
var mustache = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */
  set templateCache(cache) {
    defaultWriter.templateCache = cache;
  },
  /**
   * Gets the default or overridden caching object from the default writer.
   */
  get templateCache() {
    return defaultWriter.templateCache;
  }
};
var defaultWriter = new Writer();
mustache.clearCache = function clearCache2() {
  return defaultWriter.clearCache();
};
mustache.parse = function parse2(template, tags) {
  return defaultWriter.parse(template, tags);
};
mustache.render = function render2(template, view, partials, config) {
  if (typeof template !== "string") {
    throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
  }
  return defaultWriter.render(template, view, partials, config);
};
mustache.escape = escapeHtml;
mustache.Scanner = Scanner;
mustache.Context = Context;
mustache.Writer = Writer;
var mustache_default = mustache;

// node_modules/@vue-js-cron/core/dist/core.esm.js
var script$1 = {
  inheritAttrs: false,
  name: "RenderlessSelect",
  props: {
    multiple: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [String, Array, Object],
      default(props) {
        return props.multiple ? [] : null;
      }
    },
    items: {
      type: Array,
      default: () => []
    },
    returnObject: {
      type: Boolean,
      default: false
    },
    itemText: {
      type: String,
      default: "text"
    },
    itemValue: {
      type: String,
      default: "value"
    },
    cols: {
      type: Number,
      default: 1
    },
    selection: {
      type: String,
      default: ""
    },
    clearable: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:model-value"],
  data() {
    return {
      menu: false
    };
  },
  computed: {
    _value() {
      return this.multiple ? this.modelValue : [this.modelValue];
    },
    selectedItems() {
      return this.items.filter((item) => {
        for (const value2 of this._value) {
          if (this.returnObject) {
            if (value2 === item)
              return true;
          } else {
            if (value2 === item[this.itemValue])
              return true;
          }
        }
        return false;
      });
    },
    selectedStr() {
      return this.selection || this.selectedItems.map((item) => item[this.itemText]).join(",");
    },
    rows() {
      return Array.isArray(this.items) ? Math.ceil(this.items.length / this.cols) : 0;
    },
    itemRows() {
      return Array.from(Array(this.rows), (_, i) => {
        return Array.from(Array(this.cols), (_2, j) => {
          return this.items[this.cols * i + j];
        });
      });
    }
  },
  methods: {
    select(item) {
      if (!item) {
        return;
      }
      if (this.multiple) {
        const value2 = this.selectedItems.slice();
        const i = this.selectedItems.indexOf(item);
        if (i >= 0) {
          value2.splice(i, 1);
        } else {
          value2.push(item);
        }
        this.$emit("update:model-value", this.returnObject ? value2 : value2.map((item2) => item2[this.itemValue]));
      } else {
        this.$emit("update:model-value", this.returnObject ? item : item[this.itemValue]);
      }
    },
    isSelected(item) {
      return this.selectedItems.includes(item);
    },
    clear() {
      this.$emit("update:model-value", this.multiple ? [] : null);
    }
  },
  render() {
    if (!this.$slots || !this.$slots.default) {
      return;
    }
    return this.$slots.default({
      selectedStr: this.selectedStr,
      modelValue: this.modelValue,
      items: this.items,
      select: this.select,
      isSelected: this.isSelected,
      clearable: this.clearable && this.selectedItems.length > 0,
      clear: this.clear,
      cols: this.cols,
      rows: this.rows,
      itemRows: this.itemRows,
      multiple: this.multiple,
      itemText: this.itemText,
      itemValue: this.itemValue
    });
  }
};
script$1.__file = "src/components/renderless-select.vue";
var CronType = {
  Empty: "empty",
  Value: "value",
  Range: "range",
  EveryX: "everyX",
  Combined: "combined"
};
var Position = {
  Prefix: "prefix",
  Suffix: "suffix",
  Text: "text"
};
var Field = class {
  /**
     *
     * @param {String} name
     * @param {Array} items
     */
  constructor(id, items) {
    this.id = id;
    this.items = items;
    this.itemMap = this.items.reduce((acc, item) => {
      acc[item.value] = item;
      return acc;
    }, {});
  }
  get min() {
    return this.items[0].value;
  }
  get max() {
    return this.items[this.items.length - 1].value;
  }
  getItem(value2) {
    return this.itemMap[value2];
  }
};
var CronSegment = class {
  get type() {
    return CronType.Value;
  }
  get value() {
    return "*";
  }
};
var AnySegment = class extends CronSegment {
  get type() {
    return CronType.Empty;
  }
  get value() {
    return "*";
  }
};
var RangeSegment = class extends CronSegment {
  constructor(start, end) {
    super();
    this.start = start;
    this.end = end;
  }
  get type() {
    return CronType.Range;
  }
  get value() {
    return `${this.start}-${this.end}`;
  }
};
var EverySegment = class extends CronSegment {
  constructor(every2) {
    super();
    this.every = every2;
  }
  get type() {
    return CronType.EveryX;
  }
  get value() {
    return `*/${this.every}`;
  }
};
var ValueSegment = class extends CronSegment {
  constructor(value2) {
    super();
    this.val = value2;
  }
  get type() {
    return CronType.Value;
  }
  get value() {
    return "" + this.val;
  }
};
var CombinedSegment = class extends CronSegment {
  constructor(segments = []) {
    super();
    this.segments = segments;
  }
  get type() {
    return CronType.Combined;
  }
  addSegment(cronSegment) {
    this.segments.push(cronSegment);
  }
  get value() {
    return this.segments.map((c) => c.value).join(",");
  }
};
function range$1(start, end, step = 1) {
  const r = [];
  for (let i = start; i <= end; i += step) {
    r.push(i);
  }
  return r;
}
var Range = class {
  constructor(start, end, step = 1) {
    this.start = start;
    this.end = end;
    this.step = step;
    return new Proxy(this, {
      get: function(target, prop) {
        const i = typeof prop === "string" ? parseInt(prop) : prop;
        if (typeof i === "number" && i >= 0 && i <= target.length) {
          return target.start + target.step * i;
        }
        return Reflect.get(...arguments);
      }
    });
  }
  get length() {
    return parseInt((this.end - this.start) / this.step) + 1;
  }
  [Symbol.iterator]() {
    let index = -1;
    return {
      next: () => {
        return { value: this[++index], done: !(this[index + 1] !== void 0) };
      }
    };
  }
};
function getValue(params, key) {
  const keys = key.split(".");
  let value2 = params;
  for (const k of keys) {
    value2 = value2[k];
  }
  return value2;
}
function format(str, params) {
  const re2 = /\{\{\S+\}\}/gm;
  let m;
  while ((m = re2.exec(str)) !== null) {
    const key = m[0].substring(2, m[0].length - 2);
    const value2 = getValue(params, key);
    str = str.substr(0, m.index) + value2 + str.substr(m.index + m[0].length);
    re2.lastIndex = m.index;
  }
  return str;
}
function genItems$1(min, max, genText = (value2) => {
  return value2 + "";
}, genAltText = (value2) => {
  return value2 + "";
}) {
  const res = [];
  for (const i of new Range(min, max)) {
    const item = {};
    item.text = genText(i);
    item.alt = genAltText(i);
    item.value = i;
    res.push(item);
  }
  return res;
}
function pad$1(n, width) {
  n = n + "";
  return n.length < width ? new Array(width - n.length).fill("0").join("") + n : n;
}
function isObject(value2) {
  return value2 && typeof value2 === "object" && !Array.isArray(value2);
}
function deepMerge(target, ...sources) {
  if (!isObject(target) || sources.length === 0)
    return;
  const source = sources.shift();
  if (isObject(source)) {
    for (const [key, value2] of Object.entries(source)) {
      if (isObject(value2)) {
        if (!isObject(target[key])) {
          target[key] = {};
        }
        deepMerge(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    }
  }
  if (sources.length > 0)
    deepMerge(target, sources);
  return target;
}
function traverse$1(obj, ...keys) {
  if (keys.length === 0) {
    return obj;
  }
  for (const key of keys[0]) {
    if (key in obj) {
      const res = traverse$1(obj[key], ...keys.slice(1));
      if (res !== void 0) {
        return res;
      }
    }
  }
}
function populate(obj, map) {
  const res = {};
  for (const [key, value2] of Object.entries(obj)) {
    res[key] = map[value2];
  }
  return res;
}
function isSquence(numbers) {
  for (let i = 1; i < numbers.length; i++) {
    if (numbers[i - 1] + 1 !== numbers[i]) {
      return false;
    }
  }
  return true;
}
var util = {
  range: range$1,
  Range,
  format,
  genItems: genItems$1,
  pad: pad$1,
  deepMerge,
  isObject,
  traverse: traverse$1,
  populate,
  isSquence
};
function strToArray$4(str) {
  if (str !== "*") {
    return null;
  }
  return [];
}
function arrayToStr$4(arr, field) {
  const { items } = field;
  if (arr.length === 0) {
    return new AnySegment();
  }
  if (arr.length !== items.length) {
    return null;
  }
  for (const item of items) {
    if (!arr.includes(item.value)) {
      return null;
    }
  }
  if (!util.isSquence(items.map((item) => item.value))) {
    return null;
  }
  return new AnySegment();
}
var any = {
  strToArray: strToArray$4,
  arrayToStr: arrayToStr$4
};
var re$1 = /^\*\/\d+$/;
function strToArray$3(str, { min, max }) {
  if (!re$1.test(str)) {
    return null;
  }
  const [, everyStr] = str.split("/");
  const every2 = parseInt(everyStr);
  const start = every2 * parseInt(min / every2);
  const res = [];
  for (let i = start; i <= max; i += every2) {
    if (i >= min) {
      res.push(i);
    }
  }
  return res.length > 0 ? res : null;
}
function arrayToStr$3(arr, field) {
  const { min, max } = field;
  if (arr.length < 3) {
    return null;
  }
  const step = arr[1] - arr[0];
  if (step <= 1) {
    return null;
  }
  const first = min % step === 0 ? min : (parseInt(min / step) + 1) * step;
  if (arr.length !== parseInt((max - first) / step) + 1) {
    return null;
  }
  for (const value2 of arr) {
    if (value2 % step !== 0) {
      return null;
    }
  }
  return new EverySegment(step);
}
var every = {
  strToArray: strToArray$3,
  arrayToStr: arrayToStr$3
};
var re = /^\d+-\d+$/;
function strToArray$2(str, { min, max }) {
  if (!re.test(str)) {
    return null;
  }
  const range2 = str.split("-");
  const start = parseInt(range2[0]);
  const end = parseInt(range2[1]);
  if (start > end || start < min || end > max) {
    return null;
  }
  return util.range(start, end);
}
function arrayToStr$2(arr, field) {
  const { min, max } = field;
  if (arr.length <= 1) {
    return null;
  }
  const minValue = arr[0];
  const maxValue = arr[arr.length - 1];
  if (minValue < min) {
    return null;
  }
  if (maxValue > max) {
    return null;
  }
  const ranges = [];
  let start = 0;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i + 1] === void 0 || arr[i + 1] - arr[i] > 1) {
      if (i === start) {
        ranges.push(new ValueSegment(arr[start]));
      } else {
        ranges.push(new RangeSegment(arr[start], arr[i]));
      }
      start = i + 1;
    }
  }
  return new CombinedSegment(ranges);
}
var range = {
  strToArray: strToArray$2,
  arrayToStr: arrayToStr$2
};
function strToArray$1(str, { min, max }) {
  const number = parseInt(str);
  return String(number) === str && number >= min && number <= max ? [number] : null;
}
function arrayToStr$1(arr, field) {
  const { min, max } = field;
  if (Math.min(arr) < min) {
    return null;
  }
  if (Math.max(arr) > max) {
    return null;
  }
  const values = arr.map((x) => {
    return new ValueSegment(x);
  });
  return new CombinedSegment(values);
}
var value = {
  strToArray: strToArray$1,
  arrayToStr: arrayToStr$1
};
var fieldTypes = [any, every, range, value];
function strToArray(str, field) {
  const fields = str.split(",");
  const res = [];
  for (const f of fields) {
    if (f === "*") {
      return [];
    }
    let values = null;
    for (const fieldType of fieldTypes) {
      values = fieldType.strToArray(f, field);
      if (values !== null) {
        break;
      }
    }
    if (values === null) {
      return null;
    }
    res.push(...values);
  }
  return Array.from(new Set(res));
}
function arrayToStr(arr, field) {
  for (const fieldType of fieldTypes) {
    const value2 = fieldType.arrayToStr(arr, field);
    if (value2) {
      return value2;
    }
  }
  return null;
}
var multiple = {
  strToArray,
  arrayToStr
};
var cn = {
  "*": {
    prefix: "每",
    suffix: "",
    text: "未知",
    "*": {
      empty: { text: "每 {{field.id}}" },
      value: { text: "{{val.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "每 {{every.value}}" }
    },
    month: {
      "*": { prefix: "的" },
      empty: { text: "每月" },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "的" },
      empty: { text: "每日" },
      value: { text: "{{val.alt}}号" },
      range: { text: "{{start.alt}}号-{{end.alt}}号" }
    },
    dayOfWeek: {
      "*": { prefix: "的" },
      empty: { text: "一周的每一天" },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    hour: {
      "*": { prefix: "的" },
      empty: { text: "每小时" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "每分钟" }
    }
  },
  minute: {
    text: "分"
  },
  hour: {
    text: "小时",
    minute: {
      "*": {
        prefix: ":",
        suffix: "分钟"
      },
      empty: { text: "每" }
    }
  },
  day: {
    text: "天"
  },
  week: {
    text: "周",
    dayOfWeek: {
      "*": { prefix: "的" },
      empty: { text: "每天" },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    }
  },
  month: {
    text: "月",
    dayOfWeek: {
      "*": { prefix: "和" }
    },
    day: {
      prefix: "的"
    }
  },
  year: {
    text: "年",
    dayOfWeek: {
      "*": { prefix: "和" }
    }
  }
};
var da = {
  "*": {
    prefix: "Hver",
    suffix: "",
    text: "Ukendt",
    "*": {
      empty: { text: "hver {{field.id}}" },
      value: { text: "{{val.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "hver {{every.value}}" }
    },
    month: {
      "*": { prefix: "i" },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "på" }
    },
    dayOfWeek: {
      "*": { prefix: "på" },
      empty: { text: "hver dag i ugen" },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    hour: {
      "*": { prefix: "klokken" }
    },
    minute: {
      "*": { prefix: ":" }
    }
  },
  minute: {
    text: "Minut"
  },
  hour: {
    text: "Time",
    minute: {
      "*": {
        prefix: "på de(t)",
        suffix: "minutter"
      },
      empty: { text: "hver" }
    }
  },
  day: {
    text: "Dag"
  },
  week: {
    text: "Uge"
  },
  month: {
    text: "Måned",
    dayOfWeek: {
      "*": { prefix: "og" }
    }
  },
  year: {
    text: "År",
    dayOfWeek: {
      "*": { prefix: "og" }
    }
  }
};
var de = {
  "*": {
    prefix: "Jede",
    suffix: "",
    text: "Unknown",
    "*": {
      value: { text: "{{val.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "alle {{every.value}}" }
    },
    month: {
      "*": { prefix: "im" },
      empty: {
        prefix: "in",
        text: "jedem Monat"
      },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "den" },
      empty: {
        prefix: "an",
        text: "jedem Tag"
      },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Tage"
      }
    },
    dayOfWeek: {
      "*": { prefix: "am" },
      empty: {
        prefix: "an",
        text: "jedem Wochentag"
      },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    hour: {
      "*": { prefix: "um" },
      empty: {
        prefix: "zu",
        text: "jeder Stunde"
      },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Stunden"
      }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "jede Minute" },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Minuten"
      }
    }
  },
  minute: {
    text: "Minute"
  },
  hour: {
    text: "Stunde",
    minute: {
      "*": {
        prefix: "zu",
        suffix: "Minute(n)"
      },
      empty: { text: "jeder" }
    }
  },
  day: {
    prefix: "Jeden",
    text: "Tag"
  },
  week: {
    text: "Woche"
  },
  month: {
    prefix: "Jedes",
    text: "Monat"
  },
  year: {
    prefix: "Jedes",
    text: "Jahr"
  }
};
var en = {
  "*": {
    prefix: "Every",
    suffix: "",
    text: "Unknown",
    "*": {
      empty: { text: "every {{field.id}}" },
      value: { text: "{{val.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "every {{every.value}}" }
    },
    month: {
      "*": { prefix: "in" },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "on" }
    },
    dayOfWeek: {
      "*": { prefix: "on" },
      empty: { text: "every day of the week" },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    hour: {
      "*": { prefix: "at" }
    },
    minute: {
      "*": { prefix: ":" }
    }
  },
  minute: {
    text: "Minute"
  },
  hour: {
    text: "Hour",
    minute: {
      "*": {
        prefix: "at",
        suffix: "minute(s)"
      },
      empty: { text: "every" }
    }
  },
  day: {
    text: "Day"
  },
  week: {
    text: "Week"
  },
  month: {
    text: "Month",
    dayOfWeek: {
      "*": { prefix: "and" }
    }
  },
  year: {
    text: "Year",
    dayOfWeek: {
      "*": { prefix: "and" }
    }
  }
};
var es = {
  "*": {
    prefix: "todos los",
    suffix: "",
    text: "Desconocido",
    "*": {
      empty: { text: "todos los {{ field.id }}" },
      value: { text: "{{ val.text }}" },
      range: { text: "{{ start.text }}-{{ end.text }}" },
      everyX: { text: "todos/as {{ every.value }}" }
    },
    month: {
      "*": { prefix: "en" },
      empty: { text: "todos los meses" },
      value: { text: "{{ val.alt }}" },
      range: { text: "{{ start.alt }}-{{ end.alt }}" }
    },
    day: {
      "*": { prefix: "en" },
      empty: { text: "todos los días" },
      value: { text: "los días {{ val.alt }}" }
    },
    dayOfWeek: {
      "*": { prefix: "de" },
      empty: { text: "todos los días de la semana" },
      value: { text: "los {{ val.alt }}" },
      range: { text: "{{ start.alt }}-{{ end.alt }}" }
    },
    hour: {
      "*": { prefix: "a" },
      empty: { text: "todas las horas" },
      value: { text: "las {{ val.text }}" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "todos los minutos" }
    }
  },
  minute: {
    prefix: "todos los",
    text: "minutos"
  },
  hour: {
    prefix: "todas las",
    text: "horas",
    minute: {
      "*": {
        prefix: "a los",
        suffix: "minutos"
      },
      empty: { text: "todos", prefix: "a", suffix: "los minutos" }
    }
  },
  day: {
    text: "Días"
  },
  week: {
    text: "Semanas"
  },
  month: {
    text: "Meses",
    dayOfWeek: {
      "*": { prefix: "y" }
    }
  },
  year: {
    text: "años",
    dayOfWeek: {
      "*": { prefix: "y" }
    }
  }
};
var pt = {
  "*": {
    prefix: "Todo(a)",
    suffix: "",
    text: "Desconhecido",
    "*": {
      empty: { text: "todo {{field.id}}" },
      value: { text: "{{val.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "todo {{every.value}}" }
    },
    month: {
      "*": { prefix: "de" },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      empty: { text: "todo mês" }
    },
    day: {
      "*": { prefix: "no(s) dia(s)" },
      empty: { text: "todos" }
    },
    dayOfWeek: {
      "*": { prefix: "de" },
      empty: { text: "todos dias da semana" },
      value: { text: "{{val.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    hour: {
      "*": { prefix: "às" },
      empty: { text: "cada hora" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "cada minuto" }
    }
  },
  minute: {
    text: "Minuto"
  },
  hour: {
    text: "Hora",
    minute: {
      "*": {
        prefix: "e",
        suffix: "minuto(s)"
      },
      empty: { text: "cada" }
    }
  },
  day: {
    text: "Dia"
  },
  week: {
    text: "Semana"
  },
  month: {
    text: "Mês",
    dayOfWeek: {
      "*": { prefix: "e de" }
    }
  },
  year: {
    text: "Ano",
    dayOfWeek: {
      "*": { prefix: "e de" }
    }
  }
};
var { genItems, pad, traverse } = util;
var locales = {
  en,
  de,
  pt,
  es,
  da,
  zh: cn,
  "zh-cn": cn
};
var Locale = class {
  constructor(dict) {
    this.dict = dict;
  }
  getLocaleStr(...keys) {
    const k = keys.map((key) => [key, "*"]);
    return traverse(this.dict, ...k) || "";
  }
  render(periodId, fieldId, cronType, position, params) {
    const template = this.getLocaleStr(periodId, fieldId, cronType, position);
    return mustache_default.render(template, params || {});
  }
};
function getLocale(locale2, mixin) {
  const [language] = locale2.split("-");
  const l = locales[locale2.toLowerCase()] || locales[language.toLowerCase()] || locales.en;
  const dict = util.deepMerge(l, mixin || {});
  return new Locale(dict);
}
function defaultItems(locale2) {
  return {
    minuteItems: genItems(0, 59, (value2) => pad(value2, 2)),
    hourItems: genItems(0, 23, (value2) => pad(value2, 2)),
    dayItems: genItems(1, 31),
    monthItems: genItems(1, 12, (value2) => {
      return new Date(2021, value2 - 1, 1).toLocaleDateString(locale2, { month: "long" });
    }, (value2) => {
      return new Date(2021, value2 - 1, 1).toLocaleDateString(locale2, { month: "short" });
    }),
    dayOfWeekItems: genItems(0, 6, (value2) => {
      const date = new Date(2021, 0, 3 + value2);
      return date.toLocaleDateString(locale2, { weekday: "long" });
    }, (value2) => {
      const date = new Date(2021, 0, 3 + value2);
      return date.toLocaleDateString(locale2, { weekday: "short" });
    })
  };
}
var locale = Object.freeze({
  __proto__: null,
  defaultItems,
  getLocale,
  Locale
});
var script = {
  name: "VueCronCore",
  props: {
    modelValue: {
      type: String,
      default: "* * * * *"
    },
    locale: {
      type: String,
      default: "en"
    },
    fields: {
      type: Array,
      default: function(props) {
        const items = defaultItems(props.locale);
        return [
          { id: "minute", items: items.minuteItems },
          { id: "hour", items: items.hourItems },
          { id: "day", items: items.dayItems },
          { id: "month", items: items.monthItems },
          { id: "dayOfWeek", items: items.dayOfWeekItems }
        ];
      }
    },
    periods: {
      type: Array,
      default: () => {
        return [
          { id: "minute", value: [] },
          { id: "hour", value: ["minute"] },
          { id: "day", value: ["hour", "minute"] },
          { id: "week", value: ["dayOfWeek", "hour", "minute"] },
          { id: "month", value: ["day", "dayOfWeek", "hour", "minute"] },
          { id: "year", value: ["month", "day", "dayOfWeek", "hour", "minute"] }
        ];
      }
    },
    customLocale: {
      type: Object,
      default: function(props) {
        return null;
      }
    },
    mergeLocale: {
      type: Boolean,
      default: true
    }
  },
  emits: ["update:model-value", "error"],
  data() {
    const selected = {};
    for (const field of this.fields) {
      selected[field.id] = [];
    }
    return {
      selected,
      error: "",
      selectedPeriod: this.periods[this.periods.length - 1]
    };
  },
  computed: {
    splitValue() {
      return this.modelValue.split(" ");
    },
    fieldIndex() {
      return this.fields.reduce((acc, f, i) => {
        acc[f.id] = i;
        return acc;
      }, {});
    },
    periodIndex() {
      return this.periods.reduce((acc, p, i) => {
        acc[p.id] = i;
        return acc;
      });
    },
    computedFields() {
      return this.fields.map((f) => new Field(f.id, f.items));
    },
    filteredFields() {
      return this.selectedPeriod.value.map((fieldId) => {
        const i = this.fieldIndex[fieldId];
        return this.computedFields[i];
      });
    },
    _loc() {
      if (this.mergeLocale) {
        return getLocale(this.locale, this.customLocale);
      } else {
        return this.customLocale ? new Locale(this.customLocale) : getLocale(this.locale);
      }
    },
    _periods() {
      if (!this.periods) {
        return [];
      }
      return this.periods.map((p) => {
        return Object.assign({
          text: this._loc.getLocaleStr(p.id, Position.Text)
        }, p);
      });
    }
  },
  watch: {
    modelValue: {
      handler: function(value2) {
        this.cronToSelected(value2);
      },
      immediate: true
    },
    selected: {
      handler: function(selected) {
        this.selectedToCron(selected);
      },
      deep: true
    },
    selectedPeriod: {
      handler: function() {
        this.selectedToCron(this.selected);
      }
    },
    error: {
      handler: function(error) {
        this.$emit("error", error);
      }
    }
  },
  render() {
    if (!this.$slots || !this.$slots.default) {
      return;
    }
    const fieldProps = [];
    for (const field of this.filteredFields) {
      const i = this.fieldIndex[field.id];
      const values = this.selected[field.id];
      const attrs = {
        modelValue: values
      };
      const events = {
        "update:model-value": ((fieldId) => (evt) => {
          const selected = Array.from(evt).sort((a, b) => {
            return a > b ? 1 : -1;
          });
          this.selected[fieldId] = selected;
        })(field.id)
      };
      const cronSegment = multiple.arrayToStr(values, field);
      const segments = Array.isArray(cronSegment.segments) ? cronSegment.segments : [cronSegment];
      const selectedStr = segments.map((seg) => {
        const params = util.populate(seg, field.itemMap);
        params.field = field;
        return this._loc.render(this.selectedPeriod.id, field.id, seg.type, Position.Text, params);
      }).join(",");
      const prefix = this._loc.getLocaleStr(this.selectedPeriod.id, field.id, cronSegment.type, Position.Prefix);
      const suffix = this._loc.getLocaleStr(this.selectedPeriod.id, field.id, cronSegment.type, Position.Suffix);
      fieldProps.push({
        ...field,
        cron: this.splitValue[i],
        selectedStr,
        events,
        attrs,
        prefix,
        suffix
      });
    }
    return this.$slots.default({
      error: this.error,
      fields: fieldProps,
      period: {
        attrs: {
          modelValue: this.selectedPeriod.id
        },
        events: {
          "update:model-value": (periodId) => {
            const i = this.periodIndex[periodId] || 0;
            this.selectedPeriod = this.periods[i];
          }
        },
        items: this._periods,
        prefix: this._loc.getLocaleStr(this.selectedPeriod.id, Position.Prefix),
        suffix: this._loc.getLocaleStr(this.selectedPeriod.id, Position.Suffix)
      }
    });
  },
  methods: {
    defaultValue() {
      return new Array(this.fields.length).fill("*").join(" ");
    },
    cronToSelected(value2) {
      if (!value2) {
        this.$emit("update:model-value", this.defaultValue());
        return;
      }
      if (this.splitValue.length !== this.fields.length) {
        this.error = "invalid pattern";
        return;
      }
      for (let i = 0; i < this.splitValue.length; i++) {
        const field = this.computedFields[i];
        if (!this.selectedPeriod.value.includes(field.id)) {
          continue;
        }
        const array = multiple.strToArray(this.splitValue[i], field);
        if (array === null) {
          this.error = "invalid pattern";
          return;
        }
        this.selected[field.id] = array;
      }
      this.error = "";
    },
    selectedToCron(selected) {
      const strings = [];
      for (const field of this.computedFields) {
        if (!this.selectedPeriod.value.includes(field.id)) {
          strings.push("*");
          continue;
        }
        const array = selected[field.id];
        const str = multiple.arrayToStr(array, field);
        if (str === null) {
          this.error = "invalid selection";
          return;
        }
        strings.push(str.value);
      }
      this.error = "";
      this.$emit("update:model-value", strings.join(" "));
    }
  }
};
script.__file = "src/core.vue";
function install(Vue) {
  if (install.installed)
    return;
  install.installed = true;
  Vue.component("CronCore", script);
}
var plugin = {
  install,
  component: script,
  util,
  locale
};

export {
  script$1,
  util,
  locale,
  script,
  install,
  plugin
};
/*! Bundled license information:

mustache/mustache.mjs:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)
*/
//# sourceMappingURL=chunk-SETMXEOR.js.map
